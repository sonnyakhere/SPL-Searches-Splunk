# EXPLOITATION
---
### Identifying Where a Brute Force Attack Originated
 - ### Refine Our Search with the Web Server Address
````
index=botsv1 sourcetype=stream:http dest="192.168.250.70"
````

Because we know our webserver is 192.168.250.70, we can look for http traffic going to that IP address. When we pivot to the source IP addresses, we are left with three source addresses of interest, two are external and one looks familiar, right?
	- Find Top src Values in stream:http based on the Web Server Destination
	- Find Top http_method Values in stream:http based on the Web Server Destination
	- Adding a HTTP Method to Narrow Our Results		
````
index=botsv1 sourcetype=stream:http dest="192.168.250.70" http_method=POST
````
	- Find Top src Values with a POST Method in stream:http based on the Web 
	Server Destination

 - ### Finding Passwords in HTTP Wire Data

Where might we see passwords during a web login?

If the website is not encrypted or it is being decrypted for logging, we may be able to see login attempts.

What field might we see username and passwords in?
````
index=botsv1 sourcetype=stream:http dest="192.168.250.70" http_method=POST form_data=*username*passwd*
````

The form_data field contains information being passed from the client browser to the web server. If we search the form_data, we can use wildcards to look for values that contain the strings “username" and "passwd” within the field. This could be a very expensive search done at scale which is why it is important to set the index= and the time picker to narrow the amount of data to be searched.
````
| table form_data
````

The table command will take a result set and place specific fields into a tabular view that is easy to read. It will also remove all other values from the result set. The values can be seen above in the form data field for both username and passwd. It is important to note that some form_data has the password near the front of the string and others have it farther back in the string.
Now that we know form_data is the field to look at for brute force login attempts and that the string “*username*passwd*” is what we are looking for, we can use the stats command to count all the source addresses and provide a nice tabulation for us.
````
| stats count by src
````

### Identifying the First Password Attempted in a Brute Force Attack
 - ### Adding Time
````
index=botsv1 sourcetype=stream:http form_data=*username*passwd* | table _time form_data
````

We have the full form_data strings here with the time. If we wanted to change the way this is displayed, what are some ways that we can do this?
- ### Reversing the Order of Output (Oldest First)
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd* | table _time form_data
| reverse
````

The reverse command takes the output of our result set and flips the order of the results. In this case, our oldest results are now on top. This gives us the form_data for the first brute force password attempt and we can look within it to find the password string.

 - ### A More Elegant Way To View the Passwords (Foreshadowing!!!)
````
```
index=botsv1 sourcetype=stream:http http_method=POST
````
```
| rex field=form_data "passwd=(?<userpassword>\w+)"
````

Using the rex command in Splunk provides a way, using regular expression syntax, to do an extraction of the password that creates a new field containing password string values that can be easily manipulated with Splunk.
````
```
| search userpassword=*
````

Returns only events where the new field userpassword exists and contains data
````
```
| reverse
````

Reverse the output returned (Oldest first)
````
```
| head 1
````

Return the first record in the data set
````
```
| table userpassword
````

Output just the userpassword field

### Extracting Passwords from Events
 - ### Extracting Passwords from form_data
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd*
````
```
| rex field=form_data "passwd=(?<userpassword>\w+)"
````

As you can see from our search the idea is that we use the rex command to extract values from the form_data field and look for a string that starts with passwd= and then immediately capture all the “word characters”, that is 0-9 A-Z and _. When it reaches the end of those character matches and hits the "&" in the data returned, it will stop capturing values. The resulting values extracted are placed in a new field called "userpassword."
````
```
| table userpassword
````

For readability sake, we use the table command at the end of the search to see the output of the extraction and ensure we are extracting our passwords correctly.

- ###  Calculating the Length
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd* | rex field=form_data "passwd=(?<userpassword>\w+)"
````
```
| eval lenpword=len(userpassword)
````

Once we have extracted the password values, we really only care about 6 character passwords because that is the length of the title of the song in the question. To calculate the length of the userpassword fields, we can use the eval command with the len function. Len is short for length. This eval command will create a field called lenpword in this case, that will give us a numeric value for each password string.
````
```
| table userpassword lenpword
````

We can add the new field to the table command to validate that our search ran as expected.

- ###  Narrowing Down the Results
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd* | rex field=form_data "passwd=(?<userpassword>\w+)" | eval lenpword=len(userpassword)
````
```
| search lenpword=6
````

We can use the search command to only return values that have lenpword equal to 6.
````
```
| table userpassword lenpword
````

Once we are satisfied with our search for the password extraction and narrowing our results to just 6 character passwords, we will be able to remove the table command.

### Using Lookups to Correlate Events
- ###  Searching a Lookup
````
```
| inputlookup cp.csv
````

With the csv added to Splunk as a lookup, we can execute searches against that data just like any other data in Splunk. To search a lookup, we use the command inputlookup to return the values in our csv file of the Coldplay songs in the discography.

- ###  Tweaking the Lookup
````
```
| inputlookup cp.csv
````

When comparing values in Splunk with a lookup, there are often two or more fields in the lookup table. There might be a description, additional contextual fields or other information. A good example would be a list of IP addresses with additional fields like city and country.

When we built our lookup, we only grabbed the song title and we left everything in mixed case. When working with lookups, case does matter, so we want to adjust our lookup a bit before looking for matches. While we could add additional columns, we will just focus on making our list of songs all lower case and creating a new table out of it.
````
```
| eval song=lower(Songs)
````

The eval command with the lower function converts all of the song names to lower case.
````
```
| fields song
````

The fields command is to reduce the returned data to a single field, and one in our new table, in this case song.
````
```
| outputlookup coldplay.csv
````

The outputlookup command will write fields and values to a new lookup, in this case, coldplay.csv.

- ###  Putting it all Together
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd* | rex field=form_data "passwd=(?<userpassword>\w+)" | eval lenpword=len(userpassword) | search lenpword=6
````

Here is our initial search that returns all passwords with a length of 6 from our events.
````
```
| eval password=lower(userpassword)
````

In lookups, case matters, so we will convert those extracted passwords to lower case using the eval command and lower function.
````
```
| lookup coldplay.csv song as password OUTPUTNEW song
````

The lookup command compares the lookup value, in this case song from the coldplay.csv file, to the password value from the events. If we get a hit, output the song.
````
```
| search song=*
````

Search for any of the results that have a song value
````
```
| table song
````

Return the values for the field song in a table

- ###  Why | search song=* ?
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd* | rex field=form_data "passwd=(?<userpassword>\w+)" | eval lenpword=len(userpassword) | search lenpword=6 | eval password=lower(userpassword) | lookup coldplay.csv song as password OUTPUTNEW song  | table song password
````

If we left out the | search song=*, we would get results back that included passwords extracted from events but did not have the song match and we would need to go through our list looking for matches. In this example, we output both the song from the lookup and the password from the event to illustrate this. To make the search tighter, we add that search string.

### Identifying the Password Used To Gain Access
- ###  What Else Do We Need?
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd* dest_ip=192.168.250.70 | rex field=form_data "passwd=(?<userpassword>\w+)"
````

Here is our password extraction. It's a good idea to be precise so let's make sure we are focusing solely on our web server in question. We can do this by adding our destination to the search.
````
```
| stats count by userpassword | sort - count
````

Once that extraction is in place, we want to see userpassword values that are used more than once. It would stand to reason that if we are brute forcing a web site, we are going to run through a password list but we are only going to retry a password that we get a positive hit on. By sorting on count, we see that the admin password of batman was used twice so we can deduce that this is the password for the admin account.

- ###  Stats Command Provides A Wider View
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd* dest_ip=192.168.250.70 | rex field=form_data "passwd=(?<userpassword>\w+)"
````

While the previous search answers the immediate question, there are additional pieces of information that we need for our investigation, including where did the login come from? If you recall, we saw a tremendous amount of activity from a single IP address, but that was not the only IP we saw.
````
```
| stats count values(src) by userpassword | sort - count
````

By adding the values function to our stats command, we can see that the brute force attack came from 23.22.63.114 but it appears that the actual penetration with the correct password came from 40.80.148.42. That is good information to add to our notes as well because we saw other activity from that 40.80.148.42 address previously.

- ###  Collecting Additional Attributes Around the Login Events
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd* dest_ip=192.168.250.70 src=40.80.148.42 | rex field=form_data "passwd=(?<userpassword>\w+)"| search userpassword=* | table _time uri userpassword
````

The next logical step is to get an idea of the time and the URI that is associated with the actual penetration. To do this, we add the source address that we identified to our search.

### Determining The Elapsed Time Between Events
- ###  Transaction Command
````
```
index=botsv1 sourcetype=stream:http  | rex field=form_data "passwd=(?<userpassword>\w+)" |search userpassword=batman

| transaction userpassword | table duration
````

The transaction command gives us an easy way to group events together based on one or more fields and returns a field called duration that calculates the difference between the first and last event in a transaction. A transaction is defined by the common value or values specified. If we wanted to calculate the length of the vulnerability scan we could do that using the source address, but if we put the source address field into this search with userpassword, we would get two distinct transactions because the login came in from two different source addresses.

The question asked us to round the answer to two decimal places. We could do this with eval and round like we previously did, but if the results are appearing within a dashboard panel, it can also be set there.

### Identifying the Number of Unique Passwords Attempted During the Brute Force Attack
- ###  Distinct Count
With the use of the distinct count (dc) function within the stats command, this becomes very easy. Distinct count will look for every unique value within a field and count them. As you can see we had 413 total events that met our password criteria. If you stop and think about it, we saw the password batman twice, so it stands to reason that we would have 412 unique passwords attempted, but distinct count provides a way for us to calculate it and reuse that search.
````
```
index=botsv1 sourcetype=stream:http form_data=*username*passwd*  | rex field=form_data "passwd=(?<userpassword>\w+)" | stats dc(userpassword)
````
